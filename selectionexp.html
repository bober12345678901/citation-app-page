// theme.js - WITH CUSTOM ALERT SYSTEM (FIXED VARIABLE NAMES & THEME SELECTOR)

// Global reference to the modal elements
let _customModalOverlay;
let _customModalTitle;
let _customModalMessage;
let _customModalOkBtn;
let _customModalCancelBtn;
let _resolveCustomConfirm; // To store the resolve function for custom confirm

// Theme Presets
const themePresets = {
    light: { bg: '#f3f4f6', text: '#1f2937', accent: '#3b82f6', boxBg: '#ffffff', border: '#d1d5db', inputBg: '#ffffff', inputText: '#1f2937', buttonText: '#ffffff', buttonPrimaryHover: '#2563eb', buttonSecondary: '#6b7280', buttonSecondaryHover: '#4b5563', buttonDanger: '#dc2626', buttonDangerHover: '#b91c1c' },
    dark: { bg: '#111827', text: '#f9fafb', accent: '#2563eb', boxBg: '#1f2937', border: '#374151', inputBg: '#374151', inputText: '#f9fafb', buttonText: '#ffffff', buttonPrimaryHover: '#3b82f6', buttonSecondary: '#9ca3af', buttonSecondaryHover: '#d1d5db', buttonDanger: '#f87171', buttonDangerHover: '#ef4444' },
    custom: { bg: '#f3f4f6', text: '#1f2937', accent: '#3b82f6', boxBg: '#ffffff', border: '#d1d5db', inputBg: '#ffffff', inputText: '#1f2937', buttonText: '#ffffff', buttonPrimaryHover: '#2563eb', buttonSecondary: '#6b7280', buttonSecondaryHover: '#4b5563', buttonDanger: '#dc2626', buttonDangerHover: '#b91c1c' }
};

/**
 * Applies the selected theme variables to the document root and body.
 * @param {string} themeName - 'light', 'dark', or 'custom'.
 * @param {object} customColors - Optional object with custom color values.
 */
function applyTheme(themeName, customColors = {}) {
    const root = document.documentElement;
    const body = document.body;
    let theme = themePresets[themeName] || themePresets.light;

    if (themeName === 'custom') {
        theme = { ...themePresets.light, ...customColors };
        // Save custom colors to sessionStorage
        sessionStorage.setItem('customThemeColors', JSON.stringify(customColors));
    } else {
        // Clear custom colors if a preset is selected
        sessionStorage.removeItem('customThemeColors');
    }

    // Apply colors
    for (const [key, value] of Object.entries(theme)) {
        // Convert camelCase key to CSS variable name (--bg-color)
        const cssVarName = '--' + key.replace(/([A-Z])/g, '-$1').toLowerCase();
        root.style.setProperty(cssVarName, value);
    }

    // Handle dark mode class
    if (themeName === 'dark' || (themeName === 'custom' && body.classList.contains('dark'))) {
        body.classList.add('dark');
        root.classList.add('dark');
    } else {
        body.classList.remove('dark');
        root.classList.remove('dark');
    }

    // Save the selected theme name
    sessionStorage.setItem('selectedTheme', themeName);

    // Toggle custom color inputs visibility
    const customColorsContainer = document.getElementById('customColorsContainer');
    if (customColorsContainer) {
        customColorsContainer.classList.toggle('hidden', themeName !== 'custom');
    }
}

/**
 * Loads the saved theme from sessionStorage and applies it.
 */
function loadTheme() {
    const savedTheme = sessionStorage.getItem('selectedTheme') || 'dark'; // Default to dark
    const customColorsData = sessionStorage.getItem('customThemeColors');
    const customColors = customColorsData ? JSON.parse(customColorsData) : {};
    const themeSelector = document.getElementById('themeSelector');

    if (themeSelector) {
        themeSelector.value = savedTheme;
    }

    applyTheme(savedTheme, customColors);

    // Apply custom colors to inputs if custom theme is selected
    if (savedTheme === 'custom') {
        const customBgColorInput = document.getElementById('customBgColor');
        const customTextColorInput = document.getElementById('customTextColor');
        const customAccentColorInput = document.getElementById('customAccentColor');
        if (customBgColorInput) customBgColorInput.value = customColors.bg || themePresets.custom.bg;
        if (customTextColorInput) customTextColorInput.value = customColors.text || themePresets.custom.text;
        if (customAccentColorInput) customAccentColorInput.value = customColors.accent || themePresets.custom.accent;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    // Tailwind CSS Configuration MUST be inside DOMContentLoaded if CDN is in head
    if (typeof tailwind !== 'undefined' && tailwind.config) {
        tailwind.config = {
            darkMode: 'class', // Enable dark mode by toggling a 'dark' class on the html element
        };
    }
    
    // --- Theme Selector Setup ---
    const themeSelector = document.getElementById('themeSelector');
    const customColorsContainer = document.getElementById('customColorsContainer');
    const customBgColorInput = document.getElementById('customBgColor');
    const customTextColorInput = document.getElementById('customTextColor');
    const customAccentColorInput = document.getElementById('customAccentColor');
    
    // 1. Load the theme on page load
    loadTheme();

    // 2. Attach the event listener to fix the dropdown issue
    if (themeSelector) {
        themeSelector.addEventListener('change', (event) => {
            const selectedTheme = event.target.value;
            applyTheme(selectedTheme);
        });
    }

    // 3. Attach listeners for custom color changes
    const colorInputs = [customBgColorInput, customTextColorInput, customAccentColorInput];
    colorInputs.forEach(input => {
        if (input) {
            input.addEventListener('input', () => {
                const customColors = {
                    bg: customBgColorInput.value,
                    text: customTextColorInput.value,
                    accent: customAccentColorInput.value,
                    // Note: Other custom colors like boxBg, border, etc., are derived or defaults
                    boxBg: customColors.bg, // Simple derivation for box/card background
                    border: customColors.text,
                    inputBg: customColors.bg,
                    inputText: customColors.text,
                    buttonPrimaryHover: customColors.accent,
                    buttonSecondary: customColors.text,
                    buttonSecondaryHover: customColors.text,
                    buttonDanger: '#dc2626',
                    buttonDangerHover: '#b91c1c'
                };
                applyTheme('custom', customColors);
            });
        }
    });
    
    // --- Custom Modal System Setup ---
    _customModalOverlay = document.getElementById('customModalOverlay');
    _customModalTitle = document.getElementById('customModalTitle');
    _customModalMessage = document.getElementById('customModalMessage');
    _customModalOkBtn = document.getElementById('customModalOkBtn');
    _customModalCancelBtn = document.getElementById('customModalCancelBtn');

    // Hide modal
    function hideCustomModal() {
        if (_customModalOverlay) {
            _customModalOverlay.classList.remove('show');
            document.body.style.overflow = ''; // Restore scrolling
        }
    }

    // Handler for OK button
    if (_customModalOkBtn) {
        _customModalOkBtn.addEventListener('click', () => {
            if (_resolveCustomConfirm) {
                // If it's a confirm modal, resolve the promise with true
                _resolveCustomConfirm(true);
                _resolveCustomConfirm = null; // Clear the resolver
            }
            hideCustomModal();
        });
    }

    // Handler for Cancel button
    if (_customModalCancelBtn) {
        _customModalCancelBtn.addEventListener('click', () => {
            if (_resolveCustomConfirm) {
                // If it's a confirm modal, resolve the promise with false
                _resolveCustomConfirm(false);
                _resolveCustomConfirm = null; // Clear the resolver
            }
            hideCustomModal();
        });
    }

    // Public function for Alerts (simple OK)
    /**
     * Shows a custom alert modal.
     * @param {string} message - The message to display.
     * @param {'Success'|'Error'|'Warning'|'Info'} type - The type of alert.
     * @returns {Promise<void>} Resolves when the user clicks OK.
     */
    window.showCustomAlert = function(message, type = "Info") {
        return new Promise((resolve) => {
            if (!_customModalOverlay || !_customModalTitle || !_customModalMessage || !_customModalOkBtn) {
                alert(message); // Fallback to native if modal elements not found
                resolve();
                return;
            }

            _customModalTitle.textContent = type;
            _customModalMessage.textContent = message;

            // Apply type-specific styling
            _customModalTitle.classList.remove('success', 'error', 'warning', 'info');
            const typeLower = type.toLowerCase();
            _customModalTitle.classList.add(typeLower);

            _customModalCancelBtn.classList.add('hidden'); // Hide cancel button for alerts
            _customModalOkBtn.classList.remove('hidden'); // Ensure OK button is visible
            _customModalOkBtn.textContent = 'OK'; // Set OK button text

            _customModalOverlay.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling background
            _customModalOkBtn.focus(); // Focus OK button

            // Set up one-time resolve on OK click for this alert instance
            const okListener = () => {
                _customModalOkBtn.removeEventListener('click', okListener);
                resolve();
                hideCustomModal();
            };

            // Use the established handler in DOMContentLoaded that calls hideCustomModal and check if _resolveCustomConfirm is set
            // For simple alerts, we use a slightly different approach to resolve immediately.
            // Since the DOMContentLoaded setup is for confirms, we will handle the resolve here.
            // Temporary fix: Re-attach the resolver for the alert's promise resolution only.
            // The global handler will just hide the modal, and the promise resolution will happen here.
            _customModalOkBtn.onclick = () => { // Temporarily override the DOMContentLoaded handler
                _customModalOkBtn.onclick = null; // Clear override
                hideCustomModal();
                resolve();
            }

        });
    };
    
    // Public function for Confirms (OK/Cancel)
    /**
     * Shows a custom confirmation modal.
     * @param {string} message - The message to display.
     * @param {string} title - The title of the modal.
     * @returns {Promise<boolean>} Resolves with true if OK is clicked, false if Cancel.
     */
    window.showCustomConfirm = function(message, title = "Confirm Action") {
        return new Promise((resolve) => {
            if (!_customModalOverlay || !_customModalTitle || !_customModalMessage || !_customModalOkBtn || !_customModalCancelBtn) {
                resolve(confirm(message)); // Fallback to native if modal elements not found
                return;
            }
            _resolveCustomConfirm = resolve; // Store the resolve function for button handlers

            _customModalTitle.textContent = title;
            _customModalMessage.textContent = message;
            _customModalTitle.classList.remove('success', 'error', 'warning', 'info'); // Clear type classes
            _customModalTitle.classList.add('info'); // Default confirm to info styling

            _customModalCancelBtn.classList.remove('hidden'); // Show cancel button for confirms
            _customModalOkBtn.classList.remove('hidden'); // Ensure OK button is visible
            _customModalOkBtn.textContent = 'OK'; // Set OK button text
            
            _customModalOkBtn.onclick = null; // Clear any alert-specific override

            _customModalOverlay.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent scrolling background
            _customModalOkBtn.focus(); // Focus OK button

            // The click listeners for _customModalOkBtn and _customModalCancelBtn are set once in DOMContentLoaded
            // and handle resolving _resolveCustomConfirm.
        });
    };
});
